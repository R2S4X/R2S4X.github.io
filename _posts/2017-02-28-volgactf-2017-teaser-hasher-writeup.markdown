---
layout: "post"
title: "[VolgaCTF 2017 Teaser] Hasher writeup"
date: "2017-02-28 14:48"
categories: writeup
---

**Задание**: [hasher.zip]({{ site.url }}/download/hasher.zip)

Задание состоит из скрипта на python и нативного модуля к нему. В скрипте нет ничего интерестного, все идет внутырь модуля. Запустив скрипт он ничего не выдаст и будет висеть без завершения работы.

После открытия модуля в IDA сразу в глаза бросаются функции `md5_init`, `md5_update`, `md5_final`. Решил сразу же самостоятельно взять md5 от строки и отослать как флаг, но к сожалению не подошло :)

Бегло просмотрев `md5_init` и `md5_update` ничего странного не заметил выглядят обычно. В `md5_final` впихнули бесконечный цикл из-за чего скрипт и не может завершить работу. Скорей всего дело в `md5_transform`, разбирать что там могли изменить не было желания.

![]({{ site.url }}/image/hasher_loop.png)

Тут не нужно ничего обращать, нужно просто получить результат функции. Следовательно не нужно усложнять себе жизнь, просто заберем значение хеша с отладчика. Для отладки этого модуля нужно немного настроить отладчик. Т.к. это python модуль, который грузится с `hasher.py` отлаживать мы будем сам python :)

![]({{ site.url }}/image/hasher_debug_options.png)

Для этого нужно изменить поле `Application` на `/usr/bin/python3`, т.к. именно эту версию интерпритатора советуют создатели задания. А также задать аргументом путь к нашему скрипту, который вызывает фунцию с модуля.

Что бы получить финальный хеш достаточно остановится на функции `md5_transform` в `md5_final`, она не имеет символьного имени, но кто знаком с реализацией `md5` тот знает. В `rdi` будет финальный кусок строки от которой считаем хеш, а в `rsi` сам `md5_ctx` в котором и содержится значение хеша.

![]({{ site.url }}/image/hasher_breakpoint.png)

Запускаем отладку, после того как остановиль на брейкпоинте делаем еще один шаг и все. Теперь забираем наш хеш с памяти

![]({{ site.url }}/image/hasher_hash.png)

```
VolgaCTF{EBA0EDF09B048610FCC94938F2E0F79F}
```
